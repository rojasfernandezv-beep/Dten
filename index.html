<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Checkout System</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'primary': '#4f46e5',
                        'success': '#10b981', /* Green */
                        'danger': '#ef4444',  /* Red */
                        'warning': '#f59e0b', /* Amber */
                        'info': '#3b82f6',    /* Blue for Reservation */
                    }
                }
            }
        }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 sm:p-8">
    <div class="max-w-4xl mx-auto bg-white shadow-2xl rounded-xl p-6 sm:p-8">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-2 border-b pb-4">Device Checkout Hub</h1>
        
        <div id="error-message" class="hidden p-4 mb-4 text-sm text-danger bg-red-100 bg-opacity-70 rounded-lg" role="alert"></div>
        
        <!-- User Information Form (Required for Checkout/Reservation/Confirmation) -->
        <h2 class="text-2xl font-semibold text-gray-700 mb-3">Your Information for Action & Confirmation</h2>
        <p class="text-sm text-gray-600 mb-4">Please enter your details here for **new** checkouts/reservations, or to **confirm** your identity for check-ins and cancellations.</p>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8 p-4 border border-gray-200 rounded-xl bg-indigo-50/50">
            <div>
                <label for="user-name-input" class="block text-sm font-medium text-gray-700">Full Name</label>
                <input
                    type="text"
                    id="user-name-input"
                    placeholder="Jane Doe"
                    class="w-full p-2 border border-gray-300 rounded-lg mt-1 focus:ring-primary focus:border-primary"
                >
            </div>
            <div>
                <label for="user-email-input" class="block text-sm font-medium text-gray-700">Email Address</label>
                <input
                    type="email"
                    id="user-email-input"
                    placeholder="jane@company.com"
                    class="w-full p-2 border border-gray-300 rounded-lg mt-1 focus:ring-primary focus:border-primary"
                >
            </div>
            <div>
                <!-- Label is 'Select a date' -->
                <label for="return-date-input" class="block text-sm font-medium text-gray-700">Select Start Date</label>
                <input
                    type="date"
                    id="return-date-input"
                    class="w-full p-2 border border-gray-300 rounded-lg mt-1 focus:ring-primary focus:border-primary"
                    min="${new Date().toISOString().split('T')[0]}"
                >
            </div>
        </div>
        
        <!-- Device List Container -->
        <h2 class="text-2xl font-semibold text-gray-700 mb-4">Device Status</h2>

        <!-- Action Buttons Container: Seed and Clear -->
        <div id="seed-data-container" class="mt-4 mb-8 flex space-x-4 items-start">
            <div>
                <button id="seed-data-button" class="py-2 px-4 rounded-lg text-white font-medium transition duration-150 bg-warning hover:bg-amber-600 disabled:opacity-50">
                    Seed Initial Device Data
                </button>
                <p class="text-sm text-gray-500 mt-2">Click this to add initial devices to the system.</p>
            </div>
            <div>
                <button id="clear-data-button" class="py-2 px-4 rounded-lg text-white font-medium transition duration-150 bg-danger hover:bg-red-600 disabled:opacity-50">
                    Clear All Data (Devices & Reservations)
                </button>
                <p class="text-sm text-gray-500 mt-2">Use this to remove all devices and all reservation data from the database.</p>
            </div>
        </div>
        <!-- END Action Buttons Container -->

        <div id="device-list" class="space-y-4">
            <div id="loading-spinner" class="flex justify-center items-center py-10">
                <svg class="animate-spin h-8 w-8 text-primary" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            </div>
        </div>
    </div>

    <!-- Firebase SDK Imports and Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, onSnapshot, updateDoc, doc, setLogLevel, getDoc, setDoc, getDocs, deleteDoc, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- HARDCODED ESSENTIALS (Using user's provided details for robustness) ---
        const ESSENTIAL_FIREBASE_DEFAULTS = {
            apiKey: "AIzaSyB52DNsoD0DutAWJCnQZUGHQYwpBqwB0CM", 
            projectId: "device-checkout-system",
        };
        // -------------------------------------------------------------------------

        // --- Initialization Constants ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';
        
        let firebaseConfig = {};

        // 1. Attempt to parse environment config
        try {
            firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        } catch (e) {
            console.error("CRITICAL ERROR: Failed to parse __firebase_config. Using defaults.", e);
        }

        // 2. Guarantee the required fields using the fallback if missing
        if (!firebaseConfig.apiKey) {
            firebaseConfig.apiKey = ESSENTIAL_FIREBASE_DEFAULTS.apiKey;
            console.warn("API Key was missing from environment config. Using hardcoded fallback.");
        }
        if (!firebaseConfig.projectId) {
            firebaseConfig.projectId = ESSENTIAL_FIREBASE_DEFAULTS.projectId;
            console.warn("Project ID was missing from environment config. Using hardcoded fallback.");
        }
        
        const DOM = {
            error: document.getElementById('error-message'),
            list: document.getElementById('device-list'),
            spinner: document.getElementById('loading-spinner'),
            nameInput: document.getElementById('user-name-input'),
            emailInput: document.getElementById('user-email-input'),
            returnDateInput: document.getElementById('return-date-input'),
            seedContainer: document.getElementById('seed-data-container'),
            seedButton: document.getElementById('seed-data-button'),
            clearButton: document.getElementById('clear-data-button'), 
        };

        let db, auth, userId = null;
        let devicesCollectionRef = null;
        let reservationsCollectionRef = null; 
        
        let currentDevices = []; // Holds the latest data from device snapshot
        let reservationsByDevice = {}; // { deviceId: [{...reservation data...}, ...] }

        // --- Utility Functions ---

        function displayError(message) {
            console.error(message);
            DOM.error.textContent = message;
            DOM.error.classList.remove('hidden');
        }

        function clearError() {
            DOM.error.classList.add('hidden');
            DOM.error.textContent = '';
        }

        function getUserInfo() {
            const name = DOM.nameInput.value.trim();
            const email = DOM.emailInput.value.trim();
            const date = DOM.returnDateInput.value; // Now represents reservation START date or expected return date
            
            if (!name || !email || !date) {
                displayError("Please enter your Full Name, Email, and select a date.");
                return null;
            }
            return { name, email, date };
        }
        
        /**
         * Finds the latest date this device is unavailable (either checked out or has a queued reservation).
         * @param {string} deviceId 
         * @param {string | null} currentReturnDate The expectedReturnDate if the device is checked out.
         * @returns {string} The latest unavailable date string (YYYY-MM-DD).
         */
        function getLatestUnavailableDate(deviceId, currentReturnDate) {
            const reservations = reservationsByDevice[deviceId] || [];
            
            // Start with today's date if the device isn't checked out
            let latestDate = currentReturnDate || new Date().toISOString().split('T')[0]; 

            if (reservations.length > 0) {
                // Since the queue is sorted by startDate in the listener, the last element has the latest date
                const lastReservation = reservations[reservations.length - 1];
                
                // Compare the device's current return date with the last reservation's start date
                if (lastReservation.startDate > latestDate) {
                    latestDate = lastReservation.startDate;
                }
            }
            return latestDate;
        }

        // --- Firestore Operations ---

        /**
         * Deletes all documents in both the devices and reservations collections.
         */
        async function deleteAllData() {
            if (!devicesCollectionRef || !reservationsCollectionRef) return displayError("Database not initialized for clearing.");

            DOM.seedButton.disabled = true;
            DOM.clearButton.disabled = true;
            DOM.clearButton.textContent = 'Clearing...';

            try {
                // 1. Delete Devices
                const deviceSnapshot = await getDocs(query(devicesCollectionRef));
                const deviceDeletePromises = deviceSnapshot.docs.map(docSnap => deleteDoc(doc(db, devicesCollectionRef.path, docSnap.id)));
                
                // 2. Delete Reservations
                const reservationSnapshot = await getDocs(query(reservationsCollectionRef));
                const reservationDeletePromises = reservationSnapshot.docs.map(docSnap => deleteDoc(doc(db, reservationsCollectionRef.path, docSnap.id)));
                
                await Promise.all([...deviceDeletePromises, ...reservationDeletePromises]);
                
                console.log(`Successfully deleted ${deviceDeletePromises.length} devices and ${reservationDeletePromises.length} reservations.`);
                clearError();
                
            } catch (e) {
                displayError(`Error clearing data: ${e.message}.`);
            } finally {
                DOM.seedButton.disabled = false;
                DOM.clearButton.disabled = false;
                DOM.clearButton.textContent = 'Clear All Data (Devices & Reservations)';
            }
        }

        /**
         * Adds initial devices (if defined) to the Firestore collection.
         */
        async function seedInitialData() {
            if (!devicesCollectionRef) return displayError("Database not initialized for seeding.");

            // Define the devices to be added. 
            const devicesToSeed = [
                { id: "DTEN-Board", name: "DTEN Board", status: "available" }, 
                { id: "Poly-Studio", name: "Poly Studio P15", status: "available" }
            ];
            
            if (devicesToSeed.length === 0) {
                 return displayError("No devices are defined in the seed data array to be added.");
            }

            DOM.seedButton.disabled = true;
            DOM.seedButton.textContent = 'Seeding... Please wait.';


            try {
                console.log(`Starting database seeding with ${devicesToSeed.length} devices...`);
                
                const setPromises = devicesToSeed.map(device => {
                    const docRef = doc(db, devicesCollectionRef.path, device.id); 
                    return setDoc(docRef, { 
                        name: device.name, 
                        status: device.status,
                        // Ensure all checkout fields are null on creation
                        checkedOutBy: null,
                        checkedOutByUserName: null,
                        checkedOutByUserEmail: null,
                        expectedReturnDate: null,
                        checkedOutAt: null,
                    }, { merge: true });
                });
                
                await Promise.all(setPromises);
                
                console.log("Database seeding complete. Devices added.");
                clearError();
            } catch (e) {
                displayError(`Error seeding data: ${e.message}`);
            } finally {
                DOM.seedButton.disabled = false;
                DOM.seedButton.textContent = 'Seed Initial Device Data';
            }
        }
        
        /**
         * Updates the device status or adds a reservation.
         * @param {string} deviceId 
         * @param {'checked_out'|'check_in'|'reserve'|'cancel_reservation'|'checkout_reserved'} action 
         */
        async function updateDeviceStatus(deviceId, action) {
            if (!userId) {
                return displayError("Authentication is pending. Please wait a moment before taking action.");
            }
            if (!devicesCollectionRef || !reservationsCollectionRef) return displayError("Database not initialized.");
            
            const needsFormInfo = (action === 'checked_out' || action === 'reserve');
            const userInfo = needsFormInfo ? getUserInfo() : null;
            if (needsFormInfo && !userInfo) return; // Error handled by getUserInfo

            const docRef = doc(db, devicesCollectionRef.path, deviceId);
            let currentDevice = null;
            
            try {
                const docSnap = await getDoc(docRef);
                if (!docSnap.exists()) {
                    return displayError("Device not found.");
                }
                currentDevice = docSnap.data();
            } catch(e) {
                return displayError(`Failed to read device state for validation: ${e.message}`);
            }

            // Get the current reservation queue for validation and next action
            const deviceReservations = reservationsByDevice[deviceId] || [];
            const nextReservation = deviceReservations.length > 0 ? deviceReservations[0] : null;

            let updateData = {};
            let newStatus = '';
            
            // Common clear payload for checkout fields
            const clearCheckoutPayload = {
                checkedOutBy: null,
                checkedOutByUserName: null,
                checkedOutByUserEmail: null,
                expectedReturnDate: null,
                checkedOutAt: null,
            };

            switch (action) {
                case 'checked_out':
                    newStatus = 'checked_out';
                    updateData = {
                        status: newStatus,
                        ...clearCheckoutPayload, // Clear old checkout fields
                        checkedOutBy: userId,
                        checkedOutByUserName: userInfo.name,
                        checkedOutByUserEmail: userInfo.email,
                        expectedReturnDate: userInfo.date,
                        checkedOutAt: new Date().toISOString(),
                    };
                    break;

                case 'check_in':
                    // If there's a reservation in the queue, change status to 'reserved', otherwise 'available'
                    newStatus = nextReservation ? 'reserved' : 'available';
                    
                    updateData = {
                        status: newStatus,
                        ...clearCheckoutPayload, // Clear all checkout fields
                    };
                    break;
                
                case 'reserve':
                    // This action is used for both 'available' and 'checked_out' devices
                    const latestDate = getLatestUnavailableDate(deviceId, currentDevice.expectedReturnDate);
                    
                    if (userInfo.date <= latestDate) {
                        return displayError(`Your reservation date (${userInfo.date}) must be strictly after the device's expected return or last reserved date (${latestDate}). Current latest date: ${latestDate}.`);
                    }

                    const reservationDoc = {
                        deviceId: deviceId,
                        userId: userId,
                        userName: userInfo.name,
                        userEmail: userInfo.email,
                        startDate: userInfo.date,
                        createdAt: new Date().toISOString(),
                    };

                    // Add the new reservation to the collection
                    await addDoc(reservationsCollectionRef, reservationDoc);
                    
                    // If the device is currently 'available' or 'checked_out' but has no existing queue, change status if the queue is now populated.
                    // This logic only fires if the first reservation is being placed.
                    if (currentDevice.status === 'available' && deviceReservations.length === 0) {
                         // The device is available and we just added the first reservation
                         await updateDoc(docRef, { status: 'reserved' });
                    }
                    
                    // Reservation handled, exit switch for addDoc
                    return; 

                case 'cancel_reservation': 
                    if (!nextReservation) return displayError("No immediate reservation found to cancel.");
                    
                    // 1. Delete the first reservation document
                    await deleteDoc(doc(db, reservationsCollectionRef.path, nextReservation.id));
                    
                    // 2. Check if there are other reservations remaining (after deletion)
                    const remainingReservations = deviceReservations.filter(r => r.id !== nextReservation.id);
                    newStatus = remainingReservations.length > 0 ? 'reserved' : 'available';

                    // 3. Update device status
                    await updateDoc(docRef, { status: newStatus });
                    return; // Return because reservation was handled outside main update
                    
                case 'checkout_reserved':
                    if (!nextReservation) return displayError("No immediate reservation found to check out.");
                    
                    // 1. Delete the reservation document
                    await deleteDoc(doc(db, reservationsCollectionRef.path, nextReservation.id));
                    
                    // 2. Determine the status of the device after this checkout
                    const remainingReservationsAfterCheckout = deviceReservations.filter(r => r.id !== nextReservation.id);
                    // The device is now checked out, regardless of the remaining queue.
                    newStatus = 'checked_out';
                    
                    // 3. Perform Checkout using the reservation details
                    updateData = {
                        status: newStatus,
                        ...clearCheckoutPayload,
                        checkedOutBy: nextReservation.userId,
                        checkedOutByUserName: nextReservation.userName,
                        checkedOutByUserEmail: nextReservation.userEmail,
                        expectedReturnDate: nextReservation.startDate, // Reservation date becomes expected return date
                        checkedOutAt: new Date().toISOString(),
                    };
                    break;

                default:
                    return displayError(`Unknown action: ${action}`);
            }

            try {
                // Main device document update
                await updateDoc(docRef, updateData);
                clearError();
                console.log(`Device ${deviceId} status updated to: ${newStatus}`);
            } catch (e) {
                displayError(`Error updating device: ${e.message}`);
            }
        }

        // --- Rendering Logic ---

        function createDeviceCard(device) {
            const isCheckedOut = device.status === 'checked_out';
            const isReserved = device.status === 'reserved';
            const isAvailable = device.status === 'available';
            
            const isCheckedOutByMe = isCheckedOut && device.checkedOutBy === userId;
            const deviceReservations = reservationsByDevice[device.id] || [];
            const nextReservation = deviceReservations.length > 0 ? deviceReservations[0] : null;

            // Check for overdue checkout or expired reservation (past current date)
            const today = new Date().toISOString().split('T')[0];
            let isPastDue = false;
            let displayDate = null;
            
            if (isCheckedOut) {
                isPastDue = device.expectedReturnDate && (device.expectedReturnDate < today);
                displayDate = device.expectedReturnDate;
            } 
            
            // Determine status display
            let statusColor = 'bg-success';
            let statusText = 'Available';
            let details = '';
            
            if (isReserved) {
                // The status is 'reserved' if it's on the shelf but has a future booking
                statusColor = isPastDue ? 'bg-warning' : 'bg-info';
                statusText = 'Reserved (Next User in Queue)';
                
                if (nextReservation) {
                     details = `
                        <p class="font-bold text-info">IMMEDIATE BOOKING:</p>
                        <p><span class="font-semibold">${nextReservation.userId === userId ? 'Reserved By You' : 'Reserved By:'}</span> ${nextReservation.userName || 'Unknown'}</p>
                        <p><span class="font-semibold">Start Date:</span> ${nextReservation.startDate}</p>
                    `;
                }

            } else if (isCheckedOut) {
                statusColor = isPastDue ? 'bg-warning' : 'bg-danger';
                statusText = isPastDue ? 'OVERDUE' : 'Checked Out';
                details = `
                    <p><span class="font-semibold">${isCheckedOutByMe ? 'Checked Out By You' : 'Checked Out By:'}</span> ${device.checkedOutByUserName || 'Unknown'}</p>
                    ${device.checkedOutByUserEmail ? `<p><span class="font-semibold">Email:</span> ${device.checkedOutByUserEmail}</p>` : ''}
                    <p><span class="font-semibold">Return Date:</span> ${displayDate}</p>
                `;
            }

            // --- Full Reservation Queue List ---
            let queueDetails = '';
            if (deviceReservations.length > 0) {
                queueDetails = `
                    <div class="mt-4 pt-3 border-t border-gray-100">
                        <p class="font-bold text-sm text-info mb-1">Reservation Queue (${deviceReservations.length} total bookings):</p>
                        <ul class="text-xs space-y-1 pl-3 list-disc text-gray-700">
                            ${deviceReservations.map((res, index) => `
                                <li class="${res.userId === userId ? 'font-bold text-primary' : ''}">
                                    ${index + 1}. ${res.userName} (Starts: ${res.startDate})${index === 0 && isReserved ? ' - NEXT UP' : ''}
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                `;
            }

            // Combine details and queue for display
            const allDetails = isAvailable ? '' : `
                <div class="text-sm text-gray-600 p-3 border border-gray-100 rounded-lg bg-gray-50 max-w-sm">
                    ${details}
                    ${queueDetails}
                </div>
            `;
            
            // --- Button Logic ---
            const buttonsHtml = [];

            if (isAvailable) {
                // Available: Show Checkout and Reserve
                buttonsHtml.push(`
                    <button data-action="checked_out" class="action-btn py-2 px-4 rounded-lg text-white font-medium bg-primary hover:bg-indigo-600">
                        Check Out
                    </button>
                    <!-- Action: reserve (for the first future slot) -->
                    <button data-action="reserve" class="action-btn py-2 px-4 rounded-lg text-white font-medium bg-info hover:bg-blue-600 ml-2">
                        Reserve for Later
                    </button>
                `);
            } else if (isReserved) {
                // Device is RESERVED (on the shelf, booked for the immediate future)
                // The buttons are visible if status is 'reserved', regardless of transient nextReservation state.
                buttonsHtml.push(`
                    <button data-action="checkout_reserved" class="action-btn py-2 px-4 rounded-lg text-white font-medium bg-primary hover:bg-indigo-600">
                        Check Out Now
                    </button>
                    <button data-action="cancel_reservation" class="action-btn py-2 px-4 rounded-lg text-white font-medium bg-danger hover:bg-red-600 ml-2">
                        Cancel Reservation
                    </button>
                    <!-- Always allow chaining a reservation after the current reserved slot -->
                    <button data-action="reserve" class="action-btn py-2 px-4 rounded-lg text-white font-medium bg-info hover:bg-blue-600 ml-2">
                        Reserve for Later
                    </button>
                `);


            } else if (isCheckedOut) {
                // Device is CHECKED OUT (in use)
                if (isCheckedOutByMe) {
                    // Checked Out By Me: Show Check In
                    buttonsHtml.push(`
                        <button data-action="check_in" class="action-btn py-2 px-4 rounded-lg text-white font-medium bg-danger hover:bg-red-600">
                            Check In
                        </button>
                    `);
                } 
                
                // Checked Out by Anyone: Show Reserve for Later to join the queue
                buttonsHtml.push(`
                    <!-- Action: reserve -->
                    <button data-action="reserve" class="action-btn py-2 px-4 rounded-lg text-white font-medium bg-info hover:bg-blue-600 ${isCheckedOutByMe ? 'ml-2' : ''}">
                        Reserve for Later
                    </button>
                `);
            } else {
                // Fallback: Disabled buttons
                buttonsHtml.push(`
                    <button disabled class="py-2 px-4 rounded-lg text-white font-medium bg-gray-400 cursor-not-allowed">
                        Unavailable
                    </button>
                `);
            }


            const card = document.createElement('div');
            card.className = 'p-5 bg-white border border-gray-200 rounded-xl shadow-lg flex flex-col sm:flex-row items-start sm:items-center justify-between transition duration-200';
            
            const statusIndicator = `
                <span class="w-3 h-3 rounded-full ${statusColor} mr-4 mt-2 flex-shrink-0" aria-label="Device Status"></span>
                <div class="flex flex-col">
                    <span class="text-xl font-bold text-gray-800">${device.name}</span>
                    <span class="text-sm font-medium text-gray-600 flex items-center mb-2">
                        Status: <span class="ml-1 font-bold ${isReserved ? 'text-info' : (isCheckedOut ? (isPastDue ? 'text-warning' : 'text-danger') : 'text-success')}">${statusText}</span>
                    </span>
                    ${allDetails}
                </div>
            `;
            
            const buttonSection = `
                <div class="flex mt-3 sm:mt-0">
                    ${buttonsHtml.join('')}
                </div>
            `;

            card.innerHTML = `<div class="flex items-start mb-3 sm:mb-0">${statusIndicator}</div> ${buttonSection}`;

            // Attach event listeners to all action buttons in the card
            card.querySelectorAll('.action-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const action = button.getAttribute('data-action');
                    
                    if (userId === null) {
                        displayError("Authentication is currently pending. Please wait a moment before taking action.");
                        return; 
                    }

                    // Check for actions that require form data
                    if (action === 'checked_out' || action === 'reserve') {
                        updateDeviceStatus(device.id, action);
                    } 
                    // Check-in, Cancel, and Checkout Reserved require name/email verification
                    else if (action === 'check_in' || action === 'cancel_reservation' || action === 'checkout_reserved') {
                        const currentUserName = DOM.nameInput.value.trim();
                        const currentUserEmail = DOM.emailInput.value.trim();

                        const next = deviceReservations.length > 0 ? deviceReservations[0] : null;

                        if (action === 'check_in') {
                            const requiredUserName = device.checkedOutByUserName;
                            const requiredUserEmail = device.checkedOutByUserEmail;
                            if (!currentUserName || currentUserName !== requiredUserName ||
                                !currentUserEmail || currentUserEmail !== requiredUserEmail) {
                                 displayError(`To check in "${device.name}", please ensure your full Name and Email match the details used for checkout.`);
                                 return;
                            }
                        } else if ((action === 'cancel_reservation' || action === 'checkout_reserved')) {
                             if (!next) {
                                return displayError("There is no immediate reservation to cancel or check out.");
                             }
                             const requiredUserName = next.userName;
                             const requiredUserEmail = next.userEmail;

                             if (!currentUserName || currentUserName !== requiredUserName || 
                                 !currentUserEmail || currentUserEmail !== requiredUserEmail) {
                                  displayError(`To perform this action, please confirm your identity by entering the exact Name and Email used for the reservation.`);
                                  return;
                             }
                        }

                        updateDeviceStatus(device.id, action);
                    }
                });
            });

            return card;
        }

        function renderDeviceList(devices) {
            DOM.list.innerHTML = '';
            
            const spinner = document.getElementById('loading-spinner');
            if(spinner) spinner.remove();

            if (devices.length === 0) {
                const message = document.createElement('div');
                message.className = 'text-center text-gray-500 py-10 italic bg-gray-50 rounded-lg border border-dashed border-gray-200';
                message.innerHTML = `
                    <p class="font-semibold text-lg mb-2">No Devices Found</p>
                    <p class="mb-4">Click the **Seed** button to add the devices. (Two devices are now included in the seed array.)</p>
                    <p class="text-xs">If you already added data and still see this, check your Firebase Security Rules for read access.</p>
                `;
                DOM.list.appendChild(message);
                
                DOM.seedContainer.classList.remove('hidden');
                return;
            }
            
            // DOM.seedContainer.classList.add('hidden'); // Optional: keep buttons visible for clearing/re-seeding
            
            // Sort: Overdue/Expired > Checked Out > Reserved > Available
            devices.sort((a, b) => {
                const today = new Date().toISOString().split('T')[0];

                const isAPastDue = a.status === 'checked_out' && a.expectedReturnDate < today;
                const isBPastDue = b.status === 'checked_out' && b.expectedReturnDate < today;
                
                if (isAPastDue && !isBPastDue) return -1;
                if (isBPastDue && !isAPastDue) return 1;

                if (a.status === 'checked_out' && b.status !== 'checked_out') return -1;
                if (b.status === 'checked_out' && a.status !== 'checked_out') return 1;

                if (a.status === 'reserved' && b.status === 'available') return -1;
                if (b.status === 'reserved' && a.status === 'available') return 1;

                return 0;
            }); 

            devices.forEach(device => DOM.list.appendChild(createDeviceCard(device)));
        }


        // --- Main Initialization and Authentication ---
        
        function startReservationsListener() {
            if (!reservationsCollectionRef) return;
            
            onSnapshot(query(reservationsCollectionRef), (snapshot) => {
                const tempMap = {};
                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    if (!tempMap[data.deviceId]) {
                        tempMap[data.deviceId] = [];
                    }
                    tempMap[data.deviceId].push({ id: doc.id, ...data });
                });
                
                // Sort each queue by startDate (ascending)
                Object.keys(tempMap).forEach(deviceId => {
                    tempMap[deviceId].sort((a, b) => a.startDate.localeCompare(b.startDate));
                });

                reservationsByDevice = tempMap;
                
                // Re-render the devices to show the updated queues
                if (currentDevices.length > 0) {
                     renderDeviceList(currentDevices); 
                }
            }, (err) => {
                console.error("Reservation Listener Error:", err);
            });
        }
        
        function startDevicesListener() {
            if (!devicesCollectionRef) return;
            
            const devicesQuery = query(devicesCollectionRef);
            
            onSnapshot(devicesQuery, (snapshot) => {
                const devices = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data(),
                }));

                currentDevices = devices; 
                renderDeviceList(devices);
            }, (err) => {
                displayError(`Real-time Listener Error: ${err.message}. If the list is empty, ensure your Firebase Security Rules allow 'read' access for authenticated users.`);
            });
        }

        async function initFirebase() {
            if (!firebaseConfig.projectId || !firebaseConfig.apiKey) {
                const spinner = document.getElementById('loading-spinner');
                if(spinner) spinner.remove();
                return displayError("CRITICAL: Final configuration is still missing Project ID or API Key. Cannot proceed.");
            }
            
            // Attach button listeners
            DOM.seedButton.addEventListener('click', seedInitialData);
            DOM.clearButton.addEventListener('click', deleteAllData);

            console.log("Firebase Initialization: Using Project ID:", firebaseConfig.projectId);

            try {
                setLogLevel('debug');
                
                const app = initializeApp(firebaseConfig);
                
                db = getFirestore(app);
                auth = getAuth(app);
                
                await setPersistence(auth, browserSessionPersistence);
                
                // 1. Setup Firestore Collection References
                const deviceCollectionPath = `artifacts/${appId}/public/data/devices`;
                devicesCollectionRef = collection(db, deviceCollectionPath);
                
                const reservationsCollectionPath = `artifacts/${appId}/public/data/reservations`;
                reservationsCollectionRef = collection(db, reservationsCollectionPath);

                // 2. Start Listeners (reservations must start first, as devices depends on it for rendering)
                startReservationsListener();
                startDevicesListener();

                // 3. Perform Authentication
                const authenticateUser = async () => {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                            console.log("Authentication attempted with custom token.");
                        } else {
                            await signInAnonymously(auth);
                            console.log("Authentication attempted anonymously.");
                        }
                    } catch(e) {
                        console.error("Authentication failed:", e);
                    }
                };
                authenticateUser();

                // 4. Set up Auth State Observer
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Auth State Changed: User is authenticated with ID:", userId); 
                    } else {
                        userId = null;
                        console.log("Auth State Changed: User is not authenticated.");
                    }
                    clearError();
                });

            } catch (e) {
                const spinner = document.getElementById('loading-spinner');
                if(spinner) spinner.remove();
                displayError(`Application Error: Cannot initialize database or Firebase services. Details: ${e.message}`);
            }
        }
        

        // Start the application
        window.onload = initFirebase;
    </script>
</body>
</html>
